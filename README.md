
### 1. 게임 소개 🎮

이 게임은 플레이어가 퍼즐을 풀고, 다양한 상호작용 가능한 오브젝트를 사용하여 스테이지를 진행하는 1인칭 퍼즐 게임입니다. 터렛, 감압판, 포탈 등 여러 시스템이 유기적으로 연결되어 플레이어의 탐험과 문제 해결 능력을 시험합니다.

----------

### 2. 주요 시스템 및 기능 ✨

#### 2.1 플레이어 조작

-   **이동 및 시점 조작**: `PlayerController` 스크립트를 통해 플레이어의 이동(WASD)과 시점 조작(마우스)을 관리합니다. `FixedUpdate`를 사용하여 물리 기반의 부드러운 움직임을 구현했습니다.
    
-   **점프**: 바닥에 있을 때만 점프할 수 있도록 `isGrounded()` 메서드를 사용해 점프 가능 여부를 확인합니다.
    
-   **리스폰**: 플레이어가 특정 높이(`MINHEIGHT`) 아래로 떨어지면, `Start()` 함수에 설정된 초기 위치로 돌아가 리스폰됩니다.
    
-   **오브젝트 상호작용 (Grab)**: `IGrabable` 인터페이스를 구현한 오브젝트(예: `BoxObject`, `LaserReflecter`)를 잡고 놓을 수 있습니다. 잡는 순간 오브젝트의 `Rigidbody`를 `isKinematic` 상태로 전환하여 플레이어의 움직임에 부드럽게 종속시킵니다.
    

#### 2.2 퍼즐 및 상호작용

-   **터렛 시스템**: `TurretDetector`, `TurretController`, `SimpleTurretController` 스크립트가 적 오브젝트를 관리합니다.
    
    -   **적 탐지**: `TurretDetector`는 `OverlapSphere`와 레이캐스트를 이용해 플레이어를 탐지하고, 가장 가까운 플레이어를 `TurretController`에게 타겟으로 지정합니다.
        
    -   **터렛 동작**: `TurretController`는 탐지된 타겟을 향해 회전하고, `fireRate`에 따라 총알을 발사합니다.
        
    -   **총알**: `Bullet` 스크립트는 터렛이 발사한 총알의 속도, 데미지, 넉백 등을 관리합니다. `OnTriggerEnter`를 사용하여 방패나 벽과 같은 특정 오브젝트에 닿으면 즉시 사라지게 만들었습니다.
        
-   **문과 감압판**: `PressurePlate` 스크립트는 `OnCollisionEnter`를 통해 감압판 위에 특정 레이어의 오브젝트가 올라왔을 때 이를 감지합니다. `Door` 스크립트는 이 감압판의 활성화 상태(`IsActivated`)를 확인하여 문을 여는 조건을 제어합니다.
    
-   **레이저 반사 퍼즐**: `LaserBase`와 `LaserReflecter` 스크립트는 레이저의 발사와 반사 로직을 구현합니다. `LaserReflecter`는 `IGrabable` 인터페이스를 통해 플레이어가 직접 레이저의 경로를 조작하여 퍼즐을 풀 수 있게 합니다.
    
-   **포탈 시스템**: `Portal`, `PortalCollider`, `PortalWall` 스크립트가 포탈 기능을 구현합니다.
    
    -   **포탈 설치**: `PortalWall` 스크립트는 플레이어의 레이캐스트를 감지하여 포탈을 설치할 수 있는 벽인지 확인합니다.
        
    -   **순간이동**: `PortalCollider`는 플레이어 또는 오브젝트가 포탈에 닿으면 다른 포탈로 즉시 이동시킵니다. 이때 플레이어의 속도와 방향을 보존하여 자연스러운 이동 경험을 제공합니다.
        
    -   **재설정**: 이동 후 포탈이 비활성화되었다가 다시 활성화되어, 같은 프레임 내에서 무한 이동하는 것을 방지합니다.
        

----------

### 3. 게임 시스템

-   **진행 상황 저장**: `Clear` 스크립트는 플레이어가 클리어 영역에 진입하면 `OnStageClear()` 함수를 호출하여 게임 진행 상황을 저장하고, `ClearScene`으로 이동합니다.
    
-   **씬 관리**: `SceneManager`를 사용하여 스테이지 클리어 시 다음 씬으로 전환합니다. `Cursor.lockState`와 `Cursor.visible`을 조절하여 씬 전환 시 마우스 커서 상태를 관리합니다.
    
-   **오브젝트 풀링**: 총알과 같이 자주 생성되고 삭제되는 오브젝트는 `ObjectPool`을 통해 관리하여 런타임 성능을 최적화했습니다.
    

----------

### 4. 조작법 ⌨️

-   **이동**: `W`, `A`, `S`, `D`
    
-   **시점 변경**: 마우스
    
-   **점프**: `Space`
    
-   **오브젝트 잡기/놓기**: `E`
    
-   **달리기**: `Shift`
    
-   **포탈 발사**: `마우스 왼쪽 버튼` (파란색 포탈), `마우스 오른쪽 버튼` (주황색 포탈)
    

----------

### 5. 기술 스택  🛠️

-   **엔진**: Unity 2021.3.17f1
    
-   **언어**: C#
    
- **인터페이스 구조**: class 기반이 아닌 interface기반의 구조를 짜서 작업 진행

필요한 상황이 생길 경우에, interface를 상속받거나 클래스 내부 변수로 포함시켜 모듈화를 진행 시도

필요한 인터페이스의 경우 개발 시작전 제작을 한 후, 이를 각자 활용하는 방향으로 진행

** 리지드 바디**:
 플레이어 이동을 MovePosition으로 이동시켜 어느 방향으로 force가 가해져도 이동이 가능하도록 로직 변경
 -   MovingPlatform의 경우 Physics Material을 활용하여 플레이어가 위에 있어도 이동이 되지만, 미끄러지지 않게 설정MovingPlatform위에 있는 Player가 Bullet에 맞을 경우를 대비하여, Bullet의 경우 넉백의 ForceMode를 VelocityChange로 설정하여 날림
    -   점프의 경우, raycast를 활용하여 바닥 레이어가 map인지 확인 후 empluse를 활용하여 점프
    -   portal의 경우, 해당 rigidbody의 속도를 출구 portal의 forward방향으로 변경해주어, 
        포탈에 입장시 속도가 해당 방향으로 변화하게 설정


**Grab**:
-  인터페이스중 IGrabable을 활용하여 플레이어 그랩 시 해당 인터페이스인지를 확인 후 처리
-  Grab시, 각 IGrabable의 기능을 실행하지만, 기본적으로 해당 Rigidbody를 잠시 Kinetic으로 바꿔주어 플레이어가 들 수 있도록 설정

**DoTween** :UI/패널 애니메이션(슬라이드 효과,페이드효과,버튼 hover효과)에 DOTween 사용

**총알 ObjectPool활용**:
총알의 빈번한 Instantiate/Destroy를 막기위해 사용 , 큐를 활용하여 총알을 초기 설정한 갯수만큼 미리 생성하고 Get()으로 가져오고 Return()으로 풀로 돌려보내는 방식을 사용

 ObjectPool.cs : 게임에서 자주 생성·파괴되는 오브젝트(총알, 이펙트 등)를 미리 생성해 두고, 필요할 때 꺼내 쓰고 다시 반환하는 풀링 시스템을 관리하는 스크립트. 

Poolable.cs: 개별 오브젝트가 자신을 생성한 풀을 기억하고, 필요할 때 Despawn 하는 스크립트. 

Bullet.cs : Fire()로 총알의 초기 위치·방향·속도를 설정 충돌 시 대상에 넉백 효과를 주고 풀(ObjectPool)로 반환. lifeTime이 지나면 자동으로 소멸(Despawn). ignoredRoot를 통해 발사자를 무시하고, blockMask에 해당하는 벽/지형에 맞으면 바로 파괴되도록 설정
    

----------


### 6. 게임 진행 흐름도 (Flowchart) 📄


<img width="1343" height="421" alt="unnamed" src="https://github.com/user-attachments/assets/891d24df-e29e-4cd4-a803-fd7d1df9689f" />



----------

### 7. 팀원 소개 🧑‍💻

-   **[팀장 문장원]**: Portal부분, Player부분 제작, 프로젝트 총괄담당
    
-   **[팀원 허윤]**: laser부분, 퍼즐 디자인, StageThird 제작
    
-   **[팀원 김영식]**: Start, Select, Turret부분, Sound부분, StageTwo 제작

-  **[팀원 김우민]**: Save, Clear, Pause, PressurePlate, ClearDoor 제작

-  **[팀원 김성민]**: JumpPad, MovingPlatfrom, StageOne 제작


    

----------

### 8. 시연 영상



---------

### 9. 트러블슈팅 (Troubleshooting) ⚠️
**김성민** 
### 문제 발생 원인 

이전 코드에서는 `rb.AddForce`를 적용하기 전에 `rb.velocity = Vector3.zero;` 코드로 플레이어의 현재 속도를 강제로 `(0, 0, 0)`으로 만들었습니다. 이 때문에 플레이어가 앞으로 가던 관성이 완전히 사라지고, 오직 점프패드의 위로 향하는 힘만 받게 됩니다. 결과적으로 플레이어는 앞으로 나아가지 못하고 그 자리에서 수직으로 튕겨 올라가거나, 부자연스럽게 뒤로 밀리는 것처럼 보였습니다.

### 개선된 코드의 장점 

**1. 자연스러운 움직임**: `rb.velocity = Vector3.zero;` 코드를 제거하면서 플레이어의 기존 속도가 유지됩니다. 따라서 앞으로 움직이던 속도에 점프패드의 힘이 더해져, 플레이어는 앞으로 나아가면서 동시에 위로 점프하는 훨씬 자연스러운 움직임을 보여줍니다.

**2. 물리적 상호작용 개선**: `OnTriggerEnter`에서 `OnCollisionEnter`로 변경하면서 점프패드가 단순한 감지 영역이 아니라 물리적인 발판 역할을 하게 되었습니다. 이로 인해 플레이어는 점프패드를 "밟고" 충돌하는 것처럼 상호작용하게 되어, 게임의 물리적 리얼리티가 높아졌습니다.


### 요약

기존 코드는 플레이어의 속도를 초기화해 부자연스러운 점프를 유발했습니다. 개선된 코드는 플레이어의 관성을 유지하고, 물리 충돌을 활용해 더욱 자연스럽고 현실적인 점프패드 상호작용을 구현했습니다.

------
**문장원** 
# 상황

플레이어가 Moving Platform 위에서 플랫폼의 이동에 따라 움직이는 현상이 발생함

-   플레이어는 rigidbody의 moveposition을 사용해서 이동
-   플랫폼위에 닿을 경우, 플랫폼의 자식으로 들어감.
-   플랫폼의 이동또한 moveposition을 사용해서 구현

# 시도

1.  플랫폼의 이동을 Translate로 사용
    -   자식으로 들어간 플레이어가 키 인풋을 통해 이동을 못하는 현상 발생
2.  플레이어의 위치를 자식으로 놓지 않고 WorldPosition으로 가져와서 처리
    -   플레이어가 플랫폼을 따라서 움직이지 않음

# 원인 파악

-   PlayerController의 컴포넌트를 제거하니, 원하는 방향대로 이동을 하는것으로 파악 → PlayerController의 OnMove로직에서 문제가 발생된것으로 파악됨.
-   OnMove로직에서 MovePosition이 실제 이동되는 로직이므로, 문제 위치는 MovePosition에 존재.

# 해결 방법

-   MovePosition의 파라미터로 받는 변수의 위치를 참조 해 줄 경우 rigidbody.position을 사용 해 주어야 함.
    -   transform.position과 rigidbody.position을 넣어줬을 경우, 각각의 기능이 다르게 작동됨.
    -   transform.position을 사용 할 경우
        -   플레이어의 transform.position을 기준으로 이동하지만, 부모로 설정된 movingPlatform 또한 moveposition을 사용하여 이동하기 때문에, transform.position이 변경될 가능성이 큼, 즉 원하는 방향대로 동작하지 않고, 부모의 위치를 참조하여 추가적인 이동이 발생 할 수 있음
    -   rigidbody.position을 사용 할 경우
        -   rigidbody.position은 리지드 바디 내부에 있는 위치를 기점으로 설정하기 때문에, 부모와 관계없이 해당 rigidbody만을 참조하여 이동을 할 수 있음. 또한 transform.position을 사용하는 것보다 직관적으로 이동이 가능하며, 연산속도 또한 빠름.
-   MovePosition만 사용하면, 플레이어가 미끄러질 가능성이 있기 때문에, Physics Material을 추가로 활용하여 미끄러짐이 덜 하도록 설정 (마찰력 설정)

# 추가 정보

position의 이동 로직의 경우 두가지로 나뉘게 된다.

transform.position의 경우 전체월드 내부에서 얼마나 움직이는 지를 확인하여 움직이게 된다.

rigidbody.MovePosition 의 경우 상대 위치로부터 얼마나 움직이는 지를 확인하여 움직이게 된다.

크게 position의 이동로직은 두 분류로 나뉘게 되는데, 대부분의 Move함수들은 아래를 따르게 된다.

참조 링크 : [https://docs.unity3d.com/ScriptReference/Rigidbody-position.html](https://docs.unity3d.com/ScriptReference/Rigidbody-position.html)        


# 상황

세가지 상황을 동시에 해결해야 하는 상황이 발생

1.  첫번째 포탈을 설치 한 위치에 오브젝트가 존재하고, 이 후 두번째 포탈을 설치시 해당 오브젝트가 바로 이동하지 않는 현상
2.  오브젝트의 속도가 높아 포탈을 통한 이동을 하기 전 다른 물체에 충돌하여 속도가 초기화 되는 현상
3.  포탈 설치시 포탈의 크기가 변하는 상황 해결 및 나가는 방향으로 이동을 제어

포탈의 경우 OnTriggerEnter로 이동 로직 처리 시 Flag를 잠근 후, OnTriggerExit으로 Flag를 다시 활성화 시킴

# 시도

1.  포탈의 collider을 OnTriggerEnter 대신 OnTriggerStay 사용
    -   플레이어의 경우, 포탈 이동시, 사이즈가 크기 때문에, OnTriggerStay가 바로 불러져 이동위치가 계속해서 바뀌는 현상 발생
    -   Flag를 지정해서 처리를 하려고 시도하였지만, 물체가 탈출전까지 포탈이 비활성화 되는 문제 발생
    -   해당 사유로 콜라이더를 변경하였지만, 2번 상황이 발생
    -   리스트로 오브젝트를 저장하고, 소환 시 처리를 하는 것 또한 연산에 부하가 발생, 및 오브젝트가 탈출 시 Flag가 제대로 처리되지 않는 경우 발생
2.  포탈의 transform을 조절하여 플레이어 위치 설정
    -   해당 방식은 연산도 많고, 직관적이지도 않아서 복잡해지는 현상 발생

# 원인 파악

-   결국 OnTriggerEnter를 강제로 발생 시키면 문제가 해결 될 것이다.
-   충돌은 콜라이더를 변경해 준다면 해결이 된다.
-   회전방향을 제어해 주기 위하여 실제 콜라이더와 포탈의 forward방향을 분리해준다.

# 해결 방법

-   OnTriggerEnter을 강제로 발생 시키기 위하여, 포탈 생성 시점에서, Collider을 꺼줬다가 켜주면 OnTriggerEnter가 호출이 된다.
    -   함수는 이전에 있던 portal의 콜라이더를 껐다 킨 후, 해당 콜라이더를 껐다가 킨다.
    -   포탈 설치 시점에서 해당 함수를 호출 해주면, 1번문제가 해결이 된다.
-   포탈 콜라이더는 대신 캡슐 촐라이더를 크게 유지시켜, 플레이어가 속도가 높아도 벗어나지 않게 설정 할 수 있다.
    -   boxCollider대신 capsuleCollider을 사용한다.
    -   플레이어 내부에서 최대 속도를 제어 해 주는 로직을 추가하여, 플레이어가 너무 빨리 이동하여 충돌하거나, 맵을 벗어나는 부분을 제어한다.
    -   겹침 방지를 위해 소환을 portal의 forward방향으로 해준다.
-   포탈 프리팹에서 실제 포탈과, 회전이 된 콜라이더 따로 배치
    -   forward는 포탈에서 가져와서 오브젝트에 설정 해 주면 됨
-   포탈의 크기를 설치 시점에 벽의 크기를 참고하여 변경

# 남아있는 이슈

-   포탈을 새로 설치 시 한번은 이동이 되지만, 콜라이더가 크고 추가적인 힘을 안주다보니, 한번만 이동 후 다른 포탈에서 추가 이동을 안하는 현상 존재
----------

**허윤**
# 상황 설명

-   모든 Laser의 호출은 하나의 LaserOut 스크립트의 Update 함수에서 호출이 된다.
-   즉 Reflecter가 서로를 쏘면 너무 많은 호출로 스택 메모리가 오버플로우 되어버리는 현상이 발생

## 절차

-   스텍 메모리 오버플로우 현상 발생
    
    -   호출 a ⇒ b⇒ c ⇒ a 로 무한루프가 발생하고 있음을 확인
-   단순 상호 비교 실행
    
    -   아래와 같이 구현을 하였으나 맵에 몇개의 리플렉션과 기본적인 portal reflection까지 감안한다면 너무 추가예외가 발생하여
    -   실질적인 블로킹 역할을 하지 못했다
    
    ![](https://velog.velcdn.com/images/dev_heoyoon/post/8473cb2c-99cd-4624-9d9f-5de8c4c5ae73/image.png)
    
-   인접노드를 재귀호출하여 탐색
    
    -   자신과 같은 target이 다음 currColide이라면 그건 확실한 무한루프의 증거이므로 true를 리턴
    -   null도 아니고 다음 노드도 아닌데 타겟이 스스로인 경우 == 내부 실행이므로 작성 의도에 맞지 않으므로 false를 리턴

![](https://velog.velcdn.com/images/dev_heoyoon/post/f90c544c-1d92-499b-ab63-9912fc424893/image.png)

# 요약

-   다음 노드로 명령을 호출할때 무한루프 방지를 위한 제약이 필요하다

RenderTexture 출력 시 의도한 바 보다 어둡고 후처리가 적용되지 않았던 문제

![](https://velog.velcdn.com/images/dev_heoyoon/post/94b508b6-b6fe-44c5-ba51-c5e1adfb9d10/image.png)

1.실제 화면보다 어둡게 렌더링되는 이슈 2.PostProcessing이 적용되지 않는 이슈

> 원인파악 프로세스

-   1.  카메라의 포스트 프로세싱 옵션 OnOff확인
-   1.  Volume 스크립트 추가 여부
    
    -   Volume 프로필 적용 여부
-   1.  둘 다 확인 하였음에도 PostProcess는 적용 되나 여전히 텍스쳐가 어두운것을 발견
    
    -   텍스쳐가 투영된 오브젝트 자체에 음영이 진 가능성
    -   메쉬 자체가 음영이 진 것으로 확인
    -   머테리얼을 Unlit으로 바꾸자 음영이 제거된 것을 확인

# 마무리)

-   이번 트러블 슈팅에서 얻은 교훈은 3가지입니다.
    -   Render Texture는 텍스쳐 뿐이라는 점
    -   Shader를 통해 Render Texture도 음영을 받는다는 점
    -   카메라를 통해 Render Texture를 업데이트 해주는 과정은 캡처를 텍스쳐를 쓰는 과정이라는 점
이렇게 세가지로 마무리 지을 수 있겠습니다.
------
**김우민**
문제 발생

게임스테이지 클리어시 게임은 저장이 잘되지만 게임을 껏다가 키면 저장된 파일을 불러왔다는 디버그로그만 뜨고

게임매니저에 저장된 파일이 들어오지않는 이슈가 생겼습니다

시도

빈 오브젝트를 만들어 게임실행을 할때 클리어데이터를 가져오는 기행을 펼쳤지만 게임매니저가 들고있지않았습니다

게임매니저 스크립트에 FindObject를 사용해 세이브매니저를 강제로 들고오게 하려고했지만 해결되지않았습니다

해결

팀원분께서 도와주셨는데 savemanager가 다른 빈오브젝트가 가지고있는것을 게임매니저가 가질 수 있게 빈오브젝트를 삭제하고 실행할때 saveManager가 null일때만 addComponent를 사용해 가져오고 null일경우에 LoadClearStatus()를 불러오도록 하게 하니 해결되었습니다 .

전에 만들어놨던 코드를 살펴보니 LoadClearStatus()가 saveManager가 null일때 조건문 안에 있어서 실행이 안된 것 같았습니다.

<img width="591" height="379" alt="우민트러블" src="https://github.com/user-attachments/assets/c58f2838-0e81-4376-9437-b6dcb7178990" />


문제발견

스테이지를 클리어하게 된 후 다음스테이지 버튼을 누르게되면 1→2 스테이지는 문제가 없었지만 2→ 3스테이지갈때

다시 2스테이지로 돌아와지는 버그가 발견되었습니다

시도

1 . 다음 스테이지로 넘어가는것을 sceneCountBuildSetiing을 사용하고있었는데 scenename을 필터링할 수 있는 기능이 있다는 것을 안 후 “Stage” 로 필터링해서 구현해서 오류가 없이 진행되었지만, 다른 팀원분들한테는 오류가 발생했다

1.  스테이지 넘버인 StageCurrent( 0,1,2)를 사용하려고 배열을 이용해 클리어를 하게되면 stageCurrent에서 +1를해 찾아가게 만들어서 오류가 해결되었지만 스테이지가 늘어나면 늘어날수록 유지보수에 용이하지 않아서 기각했다
-------
**김영식**
증상: 개인브랜치에서 머지 도중 팀원의 파일이 사라짐. 
원인: 충돌 해결 과정에서 잘못된 선택으로 인한 문제발생 
해결: cmd창에서 git reset --hard <정상 커밋해시> git push --force 를 통해 정상 커밋으로 이동하여 다시작업

증상: 게임 시작시 터렛이 사이즈가 감소하는 현상 
원인: Animator가 루트에 붙어 루트의 position rotation scale을 건드는 것이 원인 
해결 : 애니메이터를 하위로 설정하여 해결

증상: 다른 씬 갔다 돌아오면 BGM이 재생되지 않음. 
원인: 씬별로 BGM을 다시 틀어주는 로직이 없음. 
해결: SceneBGM 컴포넌트 도입. 각 씬에 SceneBGM를 배치하고 OnEnable()에서 AudioManager.PlayBGM(bgmClip) 호출.

증상: 이동 플랫폼 위 플레이어가 총알을 맞아도 거의 움직이지 않음
원인: 플랫폼의 Physics Material의 마찰이 너무 커서 맞아도 날라가지 않는 현상 
해결: 총알의 넉백 판정을ForceMode.Impulse => ForceMode.VelocityChange로 변경
 
증상: 다른 씬에서 버튼 관련해서 사용하는데 문제가 발생
원인 : UIManager가 버튼/슬라이더 바인딩까지 담당하여 발생하는 문제
해결: UIManager의 역할을 StartSceneUI로 이식하여 바인딩/동작 담당하도록 처리

증상: 큐브 스폰 위치가 SpawnPoint와 다르게 적용되어 이상한 곳에 스폰되는 현상 
원인 : 자식으로 붙이니 위치가 달라지는 것이 원인 
해결: 자식으로 두되 월드위치 유지하는 방식(SetParent(cubeSpawnPoint, true))으로 해결


증상: 총알이 벽을 뚫고 나가고 그 총알을 맞은 플레이어도 벽을 뚫고 날아가는 현상 
원인: 로직에는 문제가 없었지만 벽이 너무 얇고, 총알의 속도가 빨라서 발생 
해결: 벽의 두께를 늘리는 방식(0.1 ⇒ 5)으로 해결

증상: 스크립트가 없다는 엄청난 오류메시지 발생 
원인: 에셋,스크립트등을 안쓰는 부분을 전부 정리하는 과정에서 스크립트의 위치가 변경되면서 인식하지 못하는 것이 원인 
해결: Reimport를 통해 해당 스크립트를 인식하도록 처리

----------
